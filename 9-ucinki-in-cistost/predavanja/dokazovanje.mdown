# Dokazovanje ekvivalenc med programi

Dostikrat si želimo dokazati, da nek program deluje tako, kot želimo.
Običajno je to precej zahtevna naloga, saj so programski jeziki nepredvidljivi.
V OCamlu pa so čisti programi enakovrednim svojim definicijam, zato lahko ene zamenjamo z drugimi in obratno.
Da bomo imeli kaj, s čimer bomo lahko delali, si definirajmo sledeče tri funkcije:

```ocaml
let rec (@) xs ys =
  match xs with
  | [] -> ys
  | x :: xs' -> x :: (xs' @ ys)
```

```ocaml
let rec obrni = function
  | [] -> []
  | x :: xs -> obrni xs @ [x]
```

```ocaml
let rec dolzina = function
  | [] -> 0
  | _ :: xs -> 1 + dolzina xs
```

Iz definicij takoj sledijo enačbe

1. `[] @ ys = ys`
2. `(x :: xs) @ ys = x :: (xs @ ys)`
3. `obrni [] = []`
4. `obrni (x :: xs) = obrni xs @ [x]`
5. `dolzina [] = 0`
6. `dolzina (x :: xs) = 1 + dolzina xs`

Iz teh enačb na primer takoj sledi trditev `obrni [x] = [x]`.

```
obrni [x]
= obrni (x :: [])
    (ker je `[x]` okrajšava za `x :: []`)
= [] @ [x]
    (po (3))
= [x]
    (po (1))
```


## Indukcija na seznamih

### `dolzina (xs @ ys) = dolzina xs + dolzina ys`

Tukaj enostavno odvijanje definicij ne bo pomagalo, saj izraz `dolzina (xs @ ys)` ne ustreza ne levi ne desni strani nobene od zgoraj naštetih definicij.
Namesto tega uporabimo načelo indukcije za sezname:

    P([]) ∧ (∀ z, zs. P(zs) ⇒ P(z :: zs)) ⟹ ∀ ws. P(ws)

Torej, lastnost `P` velja za vse sezname `ws`, kadar (1) velja za prazen seznam `[]` in (2) velja za sestavljen seznam `z :: zs` ob predpostavki, da velja za rep `zs`.
Načelo indukcije je podobno načelu indukcije za naravna števila:

    P(0) ∧ (∀ m. P(m) ⇒ P(m⁺)) ⟹ ∀ n. P(n)

Torej, lastnost `P` velja za vsa naravna števila `n`, kadar (1) velja za `0` in (2) velja za naslednika `m⁺` ob predpostavki, da velja za `m`.

Izjavo dokažemo z indukcijo na levi seznam. Indukcija poteka v dveh korakih:

#### Osnovni korak

V osnovnem koraku pokažemo, da enakost velja, kadar je levi seznam prazen, torej oblike `[]`:

```
dolzina ([] @ ys)
= dolzina ys
    (po (1))
= 0 + dolzina ys
    (po Peanovih aksiomih)
= dolzina [] + dolzina ys
    (po (5))
```

#### Indukcijski korak

V indukcijskem koraku pokažemo, da enakost velja za sestavljeni seznam `x :: xs` ob predpostavki, da enakost velja za seznam `xs`:

```
dolzina ((x :: xs) @ ys)
= dolzina (x :: (xs @ ys))
    (po (2))
= 1 + dolzina (xs @ ys)
    (po (6))
= 1 + (dolzina xs + dolzina ys)
    (po indukcijski prepostavki)
= (1 + dolzina xs) + dolzina ys)
    (po Peanovih aksiomih)
= dolzina (x :: xs) + dolzina ys
    (po (6))
```


### `xs @ [] = xs`

Po (1) vemo, da je `[] @ xs = xs`, torej je `[]` leva enota za `@`. To, da je `[]` tudi desna enota, pa ni samoumevno --- za dokaz uporabimo indukcijo.

#### Osnovni korak

Po (1) velja `[] @ [] = []`, kar dokaže osnovni korak.

#### Indukcijski korak

Prepostavimo, da velja `xs @ [] = xs`. Tedaj velja

```
(x :: xs) @ []
= x :: (xs @ [])
    (po (2))
= x :: xs
    (po indukcijski prepostavki)
```

kar zaključi tudi indukcijski korak.


### `xs @ (ys @ zs) = (xs @ ys) @ zs`

Operacija stikanja seznamov `@` je tudi asociativna, kar dokažemo z indukcijo na `xs`. Če zapišete dokaz asociativnosti seštevanja, lahko vidite, da poteka podobno, le da se namesto `[]` pojavlja `0`, namesto `x :: xs` pa naslednik `n⁺`.

#### Osnovni korak

```
[] @ (ys @ zs)
= ys @ zs
    (po (1))
= ([] @ ys) @ zs
    (po (1))
```

#### Indukcijski korak

Prepostavimo, da velja `xs @ (ys @ zs) = (xs @ ys) @ zs`. Tedaj velja

```
(x :: xs) @ (ys @ zs)
= x :: (xs @ (ys @ zs))
    (po (2))
= x :: ((xs @ ys) @ zs)
    (po indukcijski predpostavki)
= (x :: (xs @ ys)) @ zs
    (po (2))
= ((x :: xs) @ ys) @ zs
    (po (2))
```


### `obrni (xs @ ys) = obrni ys @ obrni xs`

#### Osnovni korak

```
obrni ([] @ ys)
= obrni ys
    (po (1))
= obrni ys @ []
    (po prej dokazani trditvi ∀ xs. xs @ [] = xs)
= obrni ys @ obrni []
    (po (3))
```

#### Indukcijski korak

```
obrni ((x :: xs) @ ys)
= obrni (x :: (xs @ ys))
    (po (2))
= obrni (xs @ ys) @ [x]
    (po (4))
= (obrni ys @ obrni xs) @ [x]
    (po indukcijski predpostavki)
= obrni ys @ (obrni xs @ [x])
    (po prej dokazani trditvi ∀ xs, ys, zs. xs @ (ys @ zs) = (xs @ ys) @ zs)
= obrni ys @ obrni (x :: xs)
    (po (4))
```


### `dolzina (obrni xs) = dolzina xs`

#### Osnovni korak

Iz definicije (3) sledi `dolzina (obrni []) = dolzina []`,

#### Indukcijski korak

Za indukcijski korak moramo pokazati, da velja `dolzina (obrni (x :: xs)) = dolzina (x :: xs)` ob indukcijski predpostavki `dolzina (obrni xs) = dolzina xs`.
Velja:

```
dolzina (obrni (x :: xs))
= dolzina (obrni xs @ [y])
    (po definiciji (4))
= dolzina (obrni xs) + dolzina [y]
    (po zgornji lemi)
= dolzina xs + dolzina [y]
    (po indukcijski predpostavki)
= dolzina xs + 1
    (po definicijah (5) in (6))
= 1 + dolzina xs
    (zaradi komutativnosti seštevanja)
= dolzina (x :: xs)
    (po definiciji (6))
```

s čimer zaključimo tudi indukcijski korak.


## Indukcija na drevesih

Načela indukcije imamo na voljo tudi na drugih vsotah.
Na primer, če definiramo tip dvojiških dreves:

```ocaml
type 'a drevo =
  | Prazno
  | Sest of 'a drevo * 'a * 'a drevo
```

zanj velja načelo indukcije:

    P(Prazno) ∧ (∀ l, x, d. P(l) ∧ P(d) ⇒ P(Sest (l, x, d))) ⟹ ∀ t. P(t)

Torej, lastnost `P` velja za vsa drevesa `t`, kadar (1) velja za prazno drevo `Prazno` in (2) velja za sestavljeno drevo `Sest (l, x, d)` ob predpostavki, da velja za otroka `l` in `d`.

Definirajmo funkciji:

```ocaml
let rec zrcali = function
  | Prazno -> Prazno
  | Sest (l, x, d) -> Sest (zrcali d, x, zrcali l)

let rec globina = function
  | Prazno -> 0
  | Sest (l, _, d) ->
      1 + max (globina l) (globina d)
```

Iz definicij sledijo enačbe

1. `zrcali Prazno = Prazno`
2. `zrcali (Sest (l, x, d)) = Sest (zrcali d, x, zrcali l)`
3. `globina Prazno = 0`
4. `globina (Sest (l, x, d)) = 1 + max (globina l) (globina d)`


### `globina (zrcali t) = globina t`

#### Osnovni korak

```
globina (zrcali Prazno)
= globina Prazno
    (po (1))
```

#### Indukcijski korak

```
globina (zrcali (Sest (l, x, d)))
= globina (Sest (zrcali d, x, zrcali l))
    (po (2))
= 1 + max (globina (zrcali d)) (globina (zrcali l))
    (po (4))
= 1 + max (globina d) (globina (zrcali l))
    (po prvi indukcijski predpostavki)
= 1 + max (globina d) (globina l)
    (po drugi indukcijski predpostavki)
= 1 + max (globina l) (globina d)
    (zaradi komutativnosti max)
= globina (Sest (l, x, d))
    (po (4))
```

## Vaje za utrjevanje

### `obrni (obrni xs) = xs`

### `zrcali (zrcali t) = t`

### `obrni xs = obrni' xs` (težja)

Kot vemo, ima funkcija `obrni`, definirana kot:

```ocaml
let rec obrni = function
  | [] -> []
  | x :: xs -> obrni xs @ [x]
```

časovno zahtevnost `O(n²)`, saj se mora zapeljati čez ves seznam, da mu na konec doda `x`.

Bolje je, če uporabimo funkcijo `obrni'`, ki uporablja akumulator in je definirana kot:

```ocaml
let obrni' =
  let rec aux acc = function
    | [] -> aux
    | x :: xs -> aux (x :: acc) xs
  in
  aux []
```

Pokažite, da za vse sezname `xs` velja `obrni xs = obrni' xs`.

### Indukcija na tipih `boole` in `'a mogoce`

Definirajmo tipa

```ocaml
type boole = Resnica | Laz
type 'a mogoce = Nic | Nekaj of 'a
```

Kakšni sta videti načeli indukcije za ta dva tipa?
