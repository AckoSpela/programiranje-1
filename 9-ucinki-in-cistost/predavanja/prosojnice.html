<!DOCTYPE html>
<html>
<head>
<title>Učinki in čistost</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../../pomozno/prosojnice.css" />
</head>
<body>
<textarea id="source">

class: center, middle

# Programiranje 1

## Učinki in čistost

### 7. december 2017

---

class: center, middle
## računalniški programi <br>~<br> matematične funkcije<br>+<br>stranski učinki

---

### Možni stranski učinki

* izpisovanje na zaslon
* branje s tipkovnice
* naključne izbire
* delo z datotekami
* spreminjanje pomnilnika
* povezovanje z drugimi računalniki
* izjeme pri izvajanju
* …

---

class: center, middle

# ugani število

.terminal.left[```markdown
Do koliko znaš šteti? 100
Izmislil sem si število med 1 in 100.
Katero število sem si izmislil? 50
Ne, moje število je manjše
Katero število sem si izmislil? 25
Ne, moje število je večje
Katero število sem si izmislil? 37
Ne, moje število je večje
Katero število sem si izmislil? 45
Ne, moje število je manjše
Katero število sem si izmislil? 42
BRAVO!
```]

---

### OCaml nudi **dva prevajalnika** izvorne kode

1. `ocamlc` prevaja v **bitno** kodo (*bytecode*)<br>
  – počasno izvajanje<br>– hitro prevajanje<br>– prenosljiva

2. `ocamlopt` prevaja v **strojno** kodo (*native code*)<br>
  – hitro izvajanje<br>– počasno prevajanje<br>– neprenosljiva

---

class: center, question

## hitrost bitne in strojne kode

  <iframe width='80%' height='40%' src='https://gfycat.com/ifr/DelightfulIncredibleAsiaticlesserfreshwaterclam'></iframe>
  <iframe width='80%' height='40%' src='https://gfycat.com/ifr/GlaringTerrificIndusriverdolphin'></iframe>

---

### Za prevajanje raje uporabljamo `ocamlbuild`,<br>saj poskrbi za pomožne datoteke

1. `ocamlbuild koda.byte` izvorno kodo `koda.ml` prevede v **bitno** kodo

2. `ocamlbuild koda.native` izvorno kodo `koda.ml` prevede v **strojno** kodo

---

class: center, middle, question

# razbitje programov<br>na datoteke

---

### Program je **čist**, če nima stranskih učinkov

1. Čisto funkcijo lahko vedno **zamenjamo** z njeno **definicijo**.

2. Čiste funkcije ob **enakih argumentih** vedno vrnejo **enake rezultate**.

---

### Vsi programi v Pythonu **niso čisti**

.source[```python
seznam = [1]
def f(x):
    seznam.append(x)
    return len(seznam)
def g(x):
    return f(x) + f(x)
```]

.terminal[```python
>>> g(3)
5
>>> f(3) + f(3)
9
>>> g(3)
13
```]

---

### Vsi **dosedanji<sup>\*</sup>** programi v OCamlu so bili čisti

.source[```
let seznam = [1]
let f x =
    let _ = x :: seznam in
    List.length seznam
let g x =
    f x + f x
```]

.terminal[```
# g 3;;
- : int = 2
# f 3 + f 3;;
- : int = 2
# g 3;;
- : int = 2
```]

---

### Nekaj definicij

```
let rec (@) xs ys =
  match xs with
  | [] -> ys
  | x :: xs ->  x :: xs @ ys

let rec obrni = function
  | [] -> []
  | x :: xs -> obrni xs @ [x]

let rec dolzina = function
  | [] -> 0
  | x :: xs -> 1 + dolzina xs
```

---

class: center, middle

# `obrni [x] = [x]`

---

#### `obrni [x] = [x]`

.consecutive[```
  obrni [x]
```]
--
.consecutive[```
= obrni (x :: [])
```]
--
.consecutive[```
= obrni [] @ [x]
```]
--
.consecutive[```
= [] @ [x]
```]
--
.consecutive[```
= [x]
```]

---

class: center, middle

### `dolzina (xs @ ys)`
### `=`
### .spoiler[`dolzina xs + dolzina ys`]

---

#### `dolzina (xs @ ys) = dolzina xs + dolzina ys`

```
  dolzina (xs @ ys)
= ???
```

--

# Kako naprej? .spoiler[Indukcija!]

---
class: center
### Indukcija na naravnih številih

### $$ P(0) \land (\forall m. P(m) \Rightarrow P(m^{+})) \implies \forall n. P(n) $$

### Indukcija na seznamih

### $$ P([]) \land (\forall x, xs. P(xs) \Rightarrow P(x :: xs)) \implies \forall ys. P(ys) $$

---

### Osnovni korak
#### `dolzina ([] @ ys) = dolzina [] + dolzina ys`


.consecutive[```
  dolzina ([] @ ys)
```]
--
.consecutive[```
= dolzina ys
```]
--
.consecutive[```
= 0 + dolzina ys
```]
--
.consecutive[```
= dolzina [] + dolzina ys
```]

---

### Indukcijski korak
#### `dolzina ((x :: xs) @ ys) = dolzina (x :: xs) + dolzina ys`

#### Predpostavka: `dolzina (xs @ ys) = dolzina xs + dolzina ys`

.consecutive[```
  dolzina ((x :: xs) @ ys)
```]
--
.consecutive[```
= dolzina (x :: (xs @ ys))
```]
--
.consecutive[```
= 1 + dolzina (xs @ ys)
```]
--
.consecutive[```
= 1 + dolzina xs + dolzina ys
```]
--
.consecutive[```
= dolzina (x :: xs) + dolzina ys
```]

---

class: center, middle
### Indukcija na naravnih številih

### $$ P(0) \land (\forall m. P(m) \Rightarrow P(m^{+})) \implies \forall n. P(n) $$

### Indukcija na seznamih

### $$ P([]) \land (\forall x, xs. P(xs) \Rightarrow P(x :: xs)) \implies \forall ys. P(ys) $$

---

### Nekaj definicij

```
type 'a drevo =
  | P
  | S of 'a drevo * 'a * 'a drevo

let rec zrcali = function
  | P -> P
  | S (l, x, d) -> S (zrcali d, x, zrcali l)

let rec globina = function
  | P -> 0
  | S (l, x, d) ->
      1 + max (globina l) (globina d)
```

---

class: center, middle

### `globina (zrcali d) = globina d`

---

class: center, middle
### Indukcija na naravnih številih

### $$ P(0) \land (\forall m. P(m) \Rightarrow P(m^{+})) \implies \forall n. P(n) $$

### Indukcija na seznamih

### $$ P([]) \land (\forall x, xs. P(xs) \Rightarrow P(x : xs)) \implies \forall ys. P(ys) $$

### Indukcija na drevesih

### $$ P(\mathtt{P}) \land (\forall x, l, d. P(l) \land P(d) \Rightarrow P(\mathtt{S}\ l\ x\ d)) \ \Rightarrow\ \forall t. P(t) $$

---

### Osnovni korak


.consecutive[```
  globina (zrcali P)
```]
--
.consecutive[```
= globina P
```]
--
.consecutive[```
= 0
```]
--
.consecutive[```
= globina P
```]

---

### Indukcijski korak

#### Predpostavki: `glbn (zrcl l) = glbn l` &nbsp;&nbsp;in&nbsp;&nbsp; `glbn (zrcl d) = glbn d`

.consecutive[```
  glbn (zrcl (S (l, x, d)))
```]
--
.consecutive[```
= glbn (S (zrcl d) x (zrcl l))
```]
--
.consecutive[```
= 1 + max (glbn (zrcl d)) (glbn (zrcl l))
```]
--
.consecutive[```
= 1 + max (glbn d) (glbn (zrcl l))
```]
--
.consecutive[```
= 1 + max (glbn d) (glbn l)
```]
--
.consecutive[```
= 1 + max (glbn l) (glbn d)
```]
--
.consecutive[```
= glbn (S (l, x, d))
```]

---

class: center, middle, question

.source.left[```
let rec obrni = function
  | [] -> []
  | x :: xs -> obrni xs @ [x]
```]

.source.left[```
let obrni' =
  let rec aux acc = function
    | [] -> aux
    | x :: xs -> aux (x :: acc) xs
  in
  aux []
```]

# `obrni xs = obrni' xs`

</textarea>
<script src="../../pomozno/prosojnice.js"></script>
</body>
</html>
